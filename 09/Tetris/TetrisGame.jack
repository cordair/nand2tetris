class TetrisGame {
    field Array pieces;
    field Board board;
    field Piece currentPiece;
    field Piece nextPiece;
    field int currentX;
    field int currentY;
    field int nextx;
    field int nexty;

    field int WIDTH;
    field int HEIGHT;
    field int score;
    field boolean gameOn;
    field boolean paused;
    field int timer;
    field int action;
    field boolean moved;

    static int TOP_SPACE;
    static int NUMBER_OF_PIECES;
    static int ROTATE;
	static int LEFT;
	static int RIGHT;
	static int DROP;
	static int DOWN;

    constructor TetrisGame new() {
        let NUMBER_OF_PIECES = 7;
        let ROTATE = 0;
        let LEFT = 1;
        let RIGHT = 2;
        let DROP = 3;
        let DOWN = 4;
        let WIDTH = 20;
        let HEIGHT = 16;
        let TOP_SPACE = 1;
        let action = -1;

        let board = Board.new(WIDTH, HEIGHT);
        let pieces = Piece.getPieces();
        return this;
    }

    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }

    method void start() {
        var int result;
        var int clear;
        var boolean failed;
        let gameOn = true;
        let timer = 1;
        do addNewPiece();

        do Renderer.renderPanel();
        while (gameOn) {
            do tick();
            let timer = timer + 1;

            if (~(currentPiece = null)) { do board.undo(); }

            do computeNextMove();
            let result = setCurrent();

            // do Output.printInt(currentX);
            // do Output.printInt(currentY);
            // do Output.printInt(result);
            // do Output.printInt(timer);
            // do Output.println();
            
            if (result = Board.PLACE_ROW_FILLED()) {
                do paintPiece(currentPiece, currentX, currentY, false);
            }
            let failed = false;
            if (result > (Board.PLACE_OUT_BOUNDS() - 1)) {
                let failed = true;
            }

            if (failed & (action = DOWN) & (~moved)) {
                do paintPiece(currentPiece, currentX, currentY, true);
                if (board.getMaxHeight() > (HEIGHT - TOP_SPACE)) { let gameOn = false; }
                else { do addNewPiece(); }
                let clear = board.clearRows();
                let score = score + (clear * 10);
                // do paint();
            }
            
            if (~failed & (~(action = DOWN))) { let moved = true; }
            else { let moved = false; }
        }
        return;
    }

    method void computeNextMove() {
        let nextx = currentX;
        let nexty = currentY;
        let nextPiece = currentPiece;
        if (action = ROTATE) {
            let nextPiece = currentPiece.rotate();
            let nextx = nextx + (nextPiece.getWidth() - currentPiece.getWidth()) / 2;
            let nexty = nexty + (nextPiece.getHeight() - currentPiece.getHeight()) / 2;
        }
        if (action = DROP) {
            let nexty = board.dropHeight(currentPiece, currentX);
            if (nexty < currentY) {
                let nexty = currentY;
            }
        }
        if (action = DOWN) {
            let nexty = currentY + 1;
        }
        if (action = LEFT) {
            let nextx = currentX - 1;
        }
        if (action = RIGHT) {
            let nextx = currentX + 1;
        }
        return;
    }

    method int setCurrent() {
        var int result;
        let result = board.placePiece(nextPiece, nextx, nexty);
        if (result < (Board.PLACE_OUT_BOUNDS() - 1)) {
            do paintPiece(currentPiece, currentX, currentY, false);
            let currentPiece = nextPiece;
            let currentX = nextx;
            let currentY = nexty;
            do paintPiece(currentPiece, currentX, currentY, true);
        }
        else { do board.undo(); }
        return result;
    }

    method void tick() {
        var int key;
        let key = Keyboard.keyPressed();
        if (key = 140) { let gameOn = false;   }   // esc key
        if (key = 128) { 
            if (paused){ let paused = true;     }
            else       { let paused = false;    }
        }                                           // enter key
        if (key = 32)  { let action = DROP;  }   // space key
        if (key = 131) { let action = ROTATE;}   // up arrow
        if (key = 133) { let action = DOWN;  }   // down arrow
        if (key = 130) { let action = LEFT;  }   // left arrow
        if (key = 132) { let action = RIGHT; }   // right arrow

        if (timer = 10) {
            let timer = timer - 10;
            let action = DOWN;
        }
        return;
    }

    method Piece pickNextPiece() {
		var int pieceNum;
		var Piece tempPiece;
        let pieceNum = Random.randRange(NUMBER_OF_PIECES);
        let tempPiece = pieces[pieceNum];
		return(tempPiece);
	}

    method void addNewPiece() {
        var int result;
        
        do board.commit();
        let currentPiece = pickNextPiece();
        let currentX = (Board.WIDTH() - currentPiece.getWidth()) / 2;
        let currentY = (TOP_SPACE + 1);
        
        return;
    }

    method void paintPanel() {
        do Renderer.renderPanel();
        return;
    }

    method void paintPiece(Piece piece, int x, int y, boolean color) {
        var Array pieceBody;
        var Point point;
        var int px, py;
        var int i;
        let pieceBody = piece.getBody();
        let i = 0;
        while (i < 4) {
            let point = pieceBody[i];
            let px = x + point.getX();
            let py = y + point.getY();
            
            do Renderer.renderBrick(px, py, color);
            let i = i + 1;
        }
        return;
    }

    method void paint() {
        var Matrix matrix;
        var Array a;
        var boolean color;
        var int px, py;
        var int i, row, col;
        let matrix = board.getBoard();
        let i = 0;
        let row = 0;
        let col = 0;
        while (row < Board.HEIGHT()) {
            let col = 0;
            let a = matrix.getRow(row);
            while (col < Board.WIDTH()) {
                let color = a[col];
                do Renderer.renderBrick(col, row, color);
                let col = col + 1;
            }
            let row = row + 1;
        }
        return;
    }
}